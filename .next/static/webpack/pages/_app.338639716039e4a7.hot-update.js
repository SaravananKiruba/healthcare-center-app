"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/services/api-nextjs.js":
/*!************************************!*\
  !*** ./src/services/api-nextjs.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiUtils: function() { return /* binding */ apiUtils; },\n/* harmony export */   authAPI: function() { return /* binding */ authAPI; },\n/* harmony export */   healthAPI: function() { return /* binding */ healthAPI; },\n/* harmony export */   investigationsAPI: function() { return /* binding */ investigationsAPI; },\n/* harmony export */   patientsAPI: function() { return /* binding */ patientsAPI; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var _utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/dataTransform */ \"./src/utils/dataTransform.js\");\n/**\r\n * Next.js API Service Module\r\n * \r\n * Enhanced API service with robust error handling, retry logic, and proper data transformation\r\n */ \n\nconst BASE_URL =  false ? 0 : \"http://localhost:3000\";\n// Create axios instance with enhanced configuration\nconst api = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n    baseURL: \"\".concat(BASE_URL, \"/api\"),\n    timeout: 30000,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    // Retry configuration\n    retry: 3,\n    retryDelay: 1000\n});\n// Enhanced error handler\nconst handleApiError = (error)=>{\n    if (error.response) {\n        // Server responded with error status\n        const { status, data } = error.response;\n        switch(status){\n            case 400:\n                throw new Error(data.message || \"Invalid request data\");\n            case 401:\n                throw new Error(\"Authentication required. Please log in again.\");\n            case 403:\n                throw new Error(\"You do not have permission to perform this action\");\n            case 404:\n                throw new Error(\"The requested resource was not found\");\n            case 409:\n                throw new Error(data.message || \"Resource conflict\");\n            case 422:\n                throw new Error(data.message || \"Validation error\");\n            case 500:\n                throw new Error(\"Internal server error. Please try again later.\");\n            default:\n                throw new Error(data.message || \"Request failed with status \".concat(status));\n        }\n    } else if (error.request) {\n        // Network error\n        throw new Error(\"Network error. Please check your connection and try again.\");\n    } else {\n        // Request setup error\n        throw new Error(error.message || \"An unexpected error occurred\");\n    }\n};\n// Retry logic for failed requests\nconst retryRequest = async (config)=>{\n    const { retry, retryDelay } = config;\n    for(let i = 0; i < retry; i++){\n        try {\n            return await (0,axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n        } catch (error) {\n            if (i === retry - 1) throw error;\n            // Don't retry client errors (4xx)\n            if (error.response && error.response.status >= 400 && error.response.status < 500) {\n                throw error;\n            }\n            // Wait before retry\n            await new Promise((resolve)=>setTimeout(resolve, retryDelay * (i + 1)));\n        }\n    }\n};\n// Enhanced request interceptor\napi.interceptors.request.use((config)=>{\n    try {\n        // Transform request data from camelCase to snake_case\n        if (config.data && typeof config.data === \"object\") {\n            // Handle nested JSON objects that might be strings\n            const processedData = {\n                ...config.data\n            };\n            // Ensure these fields are properly serialized for the API\n            [\n                \"medicalHistory\",\n                \"physicalGenerals\",\n                \"menstrualHistory\",\n                \"foodAndHabit\"\n            ].forEach((field)=>{\n                if (processedData[field] && typeof processedData[field] === \"string\") {\n                    try {\n                        processedData[field] = JSON.parse(processedData[field]);\n                    } catch (e) {\n                        // If it's already a valid JSON object, this will fail, which is fine\n                        console.log(\"Field \".concat(field, \" is already parsed or not valid JSON\"));\n                    }\n                }\n            });\n            config.data = (0,_utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__.camelToSnakeCase)(processedData);\n        }\n        // Transform URL parameters from camelCase to snake_case\n        if (config.params && typeof config.params === \"object\") {\n            config.params = (0,_utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__.camelToSnakeCase)(config.params);\n        }\n        return config;\n    } catch (error) {\n        console.error(\"Error in request interceptor:\", error);\n        return config; // Return the original config if transformation fails\n    }\n}, (error)=>{\n    return Promise.reject(error);\n});\n// Enhanced response interceptor\napi.interceptors.response.use((response)=>{\n    // Transform response data from snake_case to camelCase\n    if (response.data) {\n        response.data = (0,_utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__.snakeToCamelCase)(response.data);\n    }\n    return response;\n}, async (error)=>{\n    const config = error.config;\n    // Transform error response data from snake_case to camelCase\n    if (error.response && error.response.data) {\n        error.response.data = (0,_utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__.snakeToCamelCase)(error.response.data);\n    }\n    // Retry logic for network errors and 5xx errors\n    if (config && config.retry && (!error.response || error.response.status >= 500 && error.response.status < 600)) {\n        config.retry--;\n        await new Promise((resolve)=>setTimeout(resolve, config.retryDelay));\n        return api(config);\n    }\n    // Handle API errors\n    handleApiError(error);\n});\n// Enhanced Patients API with validation and error handling\nconst patientsAPI = {\n    getAllPatients: async function() {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        try {\n            const response = await api.get(\"/patients\", {\n                params\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch patients:\", error);\n            throw error;\n        }\n    },\n    getPatient: async (id)=>{\n        if (!id) throw new Error(\"Patient ID is required\");\n        try {\n            const response = await api.get(\"/patients/\".concat(id));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch patient \".concat(id, \":\"), error);\n            throw error;\n        }\n    },\n    createPatient: async (data)=>{\n        if (!data || typeof data !== \"object\") {\n            throw new Error(\"Valid patient data is required\");\n        }\n        // Validate required fields before sending to API\n        if (!data.name) throw new Error(\"Patient name is required\");\n        if (!data.address) throw new Error(\"Address is required\");\n        if (!data.age) throw new Error(\"Age is required\");\n        if (!data.sex) throw new Error(\"Sex is required\");\n        if (!data.mobileNumber) throw new Error(\"Mobile number is required\");\n        if (!data.chiefComplaints) throw new Error(\"Chief complaints are required\");\n        try {\n            // Ensure JSON fields are properly structured to avoid issues\n            const sanitizedData = {\n                ...data,\n                medicalHistory: data.medicalHistory || {\n                    pastHistory: {},\n                    familyHistory: {}\n                },\n                physicalGenerals: data.physicalGenerals || {},\n                foodAndHabit: data.foodAndHabit || {},\n                // Only include menstrualHistory for female patients\n                menstrualHistory: data.sex === \"Female\" ? data.menstrualHistory || {} : null\n            };\n            const response = await api.post(\"/patients\", sanitizedData);\n            return response.data;\n        } catch (error) {\n            var _error_response_data, _error_response, _error_response_data1, _error_response1, _error_response2, _error_response3;\n            console.error(\"Failed to create patient:\", error);\n            const errorMessage = ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message || \"Failed to create patient\";\n            const errorDetails = ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data1 = _error_response1.data) === null || _error_response_data1 === void 0 ? void 0 : _error_response_data1.details) || \"\";\n            console.log(\"API Error Details:\", {\n                status: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.status,\n                data: (_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.data,\n                message: errorMessage,\n                details: errorDetails\n            });\n            throw new Error(\"\".concat(errorMessage).concat(errorDetails ? \": \" + errorDetails : \"\"));\n        }\n    },\n    updatePatient: async (id, data)=>{\n        if (!id) throw new Error(\"Patient ID is required\");\n        if (!data || typeof data !== \"object\") {\n            throw new Error(\"Valid patient data is required\");\n        }\n        try {\n            const response = await api.put(\"/patients/\".concat(id), data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to update patient \".concat(id, \":\"), error);\n            throw error;\n        }\n    },\n    deletePatient: async (id)=>{\n        if (!id) throw new Error(\"Patient ID is required\");\n        try {\n            const response = await api.delete(\"/patients/\".concat(id));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to delete patient \".concat(id, \":\"), error);\n            throw error;\n        }\n    }\n};\n// Enhanced Investigations API\nconst investigationsAPI = {\n    getAllInvestigations: async function() {\n        let patientId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        try {\n            const params = patientId ? {\n                patientId\n            } : {};\n            const response = await api.get(\"/investigations\", {\n                params\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch investigations:\", error);\n            throw error;\n        }\n    },\n    getInvestigation: async (id)=>{\n        if (!id) throw new Error(\"Investigation ID is required\");\n        try {\n            const response = await api.get(\"/investigations/\".concat(id));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch investigation \".concat(id, \":\"), error);\n            throw error;\n        }\n    },\n    createInvestigation: async (data)=>{\n        if (!data || typeof data !== \"object\") {\n            throw new Error(\"Valid investigation data is required\");\n        }\n        try {\n            const response = await api.post(\"/investigations\", data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to create investigation:\", error);\n            throw error;\n        }\n    },\n    updateInvestigation: async (id, data)=>{\n        if (!id) throw new Error(\"Investigation ID is required\");\n        if (!data || typeof data !== \"object\") {\n            throw new Error(\"Valid investigation data is required\");\n        }\n        try {\n            const response = await api.put(\"/investigations/\".concat(id), data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to update investigation \".concat(id, \":\"), error);\n            throw error;\n        }\n    },\n    deleteInvestigation: async (id)=>{\n        if (!id) throw new Error(\"Investigation ID is required\");\n        try {\n            const response = await api.delete(\"/investigations/\".concat(id));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to delete investigation \".concat(id, \":\"), error);\n            throw error;\n        }\n    }\n};\n// Enhanced Auth/Users API\nconst authAPI = {\n    getCurrentUser: async ()=>{\n        try {\n            const response = await api.get(\"/users/me\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch current user:\", error);\n            throw error;\n        }\n    },\n    getUsers: async ()=>{\n        try {\n            const response = await api.get(\"/users\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch users:\", error);\n            throw error;\n        }\n    },\n    // These are handled by NextAuth, but keeping for compatibility\n    login: async (email, password)=>{\n        throw new Error(\"Use NextAuth signIn instead of this method\");\n    },\n    logout: async ()=>{\n        throw new Error(\"Use NextAuth signOut instead of this method\");\n    }\n};\n// Enhanced Health check API\nconst healthAPI = {\n    check: async ()=>{\n        try {\n            const response = await api.get(\"/health\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Health check failed:\", error);\n            throw error;\n        }\n    }\n};\n// Utility functions for common operations\nconst apiUtils = {\n    // Check if API is available\n    isApiHealthy: async ()=>{\n        try {\n            await healthAPI.check();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    },\n    // Test database connection\n    testConnection: async ()=>{\n        try {\n            const health = await healthAPI.check();\n            return health.database === \"connected\";\n        } catch (e) {\n            return false;\n        }\n    },\n    // Get API base URL\n    getBaseUrl: ()=>\"\".concat(BASE_URL, \"/api\")\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ3RDLE1BQU1BO1FBQ1I7SUFDRjtBQUNGLEVBQUU7QUFFRiwwQ0FBMEM7QUFDbkMsTUFBTW9FLFdBQVc7SUFDdEIsNEJBQTRCO0lBQzVCQyxjQUFjO1FBQ1osSUFBSTtZQUNGLE1BQU1ILFVBQVVDLEtBQUs7WUFDckIsT0FBTztRQUNULEVBQUUsVUFBTTtZQUNOLE9BQU87UUFDVDtJQUNGO0lBRUEsMkJBQTJCO0lBQzNCRyxnQkFBZ0I7UUFDZCxJQUFJO1lBQ0YsTUFBTUMsU0FBUyxNQUFNTCxVQUFVQyxLQUFLO1lBQ3BDLE9BQU9JLE9BQU9DLFFBQVEsS0FBSztRQUM3QixFQUFFLFVBQU07WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBLG1CQUFtQjtJQUNuQkMsWUFBWSxJQUFNLEdBQVksT0FBVHJGLFVBQVM7QUFDaEMsRUFBRTtBQUVGLCtEQUFlSSxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9hcGktbmV4dGpzLmpzP2Q1MmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIE5leHQuanMgQVBJIFNlcnZpY2UgTW9kdWxlXHJcbiAqIFxyXG4gKiBFbmhhbmNlZCBBUEkgc2VydmljZSB3aXRoIHJvYnVzdCBlcnJvciBoYW5kbGluZywgcmV0cnkgbG9naWMsIGFuZCBwcm9wZXIgZGF0YSB0cmFuc2Zvcm1hdGlvblxyXG4gKi9cclxuXHJcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcbmltcG9ydCB7IFxyXG4gICAgc25ha2VUb0NhbWVsQ2FzZSwgXHJcbiAgICBjYW1lbFRvU25ha2VDYXNlLFxyXG4gICAgdHJhbnNmb3JtSWZOZWVkZWQgXHJcbn0gZnJvbSAnLi4vdXRpbHMvZGF0YVRyYW5zZm9ybSc7XHJcblxyXG5jb25zdCBCQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgXHJcbiAgPyBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwczovL3lvdXItYXBwLnZlcmNlbC5hcHAnXHJcbiAgOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwJztcclxuXHJcbi8vIENyZWF0ZSBheGlvcyBpbnN0YW5jZSB3aXRoIGVuaGFuY2VkIGNvbmZpZ3VyYXRpb25cclxuY29uc3QgYXBpID0gYXhpb3MuY3JlYXRlKHtcclxuICBiYXNlVVJMOiBgJHtCQVNFX1VSTH0vYXBpYCxcclxuICB0aW1lb3V0OiAzMDAwMCxcclxuICBoZWFkZXJzOiB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIH0sXHJcbiAgLy8gUmV0cnkgY29uZmlndXJhdGlvblxyXG4gIHJldHJ5OiAzLFxyXG4gIHJldHJ5RGVsYXk6IDEwMDAsXHJcbn0pO1xyXG5cclxuLy8gRW5oYW5jZWQgZXJyb3IgaGFuZGxlclxyXG5jb25zdCBoYW5kbGVBcGlFcnJvciA9IChlcnJvcikgPT4ge1xyXG4gIGlmIChlcnJvci5yZXNwb25zZSkge1xyXG4gICAgLy8gU2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIHN0YXR1c1xyXG4gICAgY29uc3QgeyBzdGF0dXMsIGRhdGEgfSA9IGVycm9yLnJlc3BvbnNlO1xyXG4gICAgXHJcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xyXG4gICAgICBjYXNlIDQwMDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdJbnZhbGlkIHJlcXVlc3QgZGF0YScpO1xyXG4gICAgICBjYXNlIDQwMTpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkLiBQbGVhc2UgbG9nIGluIGFnYWluLicpO1xyXG4gICAgICBjYXNlIDQwMzpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24nKTtcclxuICAgICAgY2FzZSA0MDQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVxdWVzdGVkIHJlc291cmNlIHdhcyBub3QgZm91bmQnKTtcclxuICAgICAgY2FzZSA0MDk6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCAnUmVzb3VyY2UgY29uZmxpY3QnKTtcclxuICAgICAgY2FzZSA0MjI6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCAnVmFsaWRhdGlvbiBlcnJvcicpO1xyXG4gICAgICBjYXNlIDUwMDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIHNlcnZlciBlcnJvci4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8IGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyAke3N0YXR1c31gKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGVycm9yLnJlcXVlc3QpIHtcclxuICAgIC8vIE5ldHdvcmsgZXJyb3JcclxuICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayBlcnJvci4gUGxlYXNlIGNoZWNrIHlvdXIgY29ubmVjdGlvbiBhbmQgdHJ5IGFnYWluLicpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBSZXF1ZXN0IHNldHVwIGVycm9yXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCcpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFJldHJ5IGxvZ2ljIGZvciBmYWlsZWQgcmVxdWVzdHNcclxuY29uc3QgcmV0cnlSZXF1ZXN0ID0gYXN5bmMgKGNvbmZpZykgPT4ge1xyXG4gIGNvbnN0IHsgcmV0cnksIHJldHJ5RGVsYXkgfSA9IGNvbmZpZztcclxuICBcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJldHJ5OyBpKyspIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCBheGlvcyhjb25maWcpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGkgPT09IHJldHJ5IC0gMSkgdGhyb3cgZXJyb3I7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEb24ndCByZXRyeSBjbGllbnQgZXJyb3JzICg0eHgpXHJcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1cyA8IDUwMCkge1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeVxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSAqIChpICsgMSkpKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vLyBFbmhhbmNlZCByZXF1ZXN0IGludGVyY2VwdG9yXHJcbmFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXHJcbiAgKGNvbmZpZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YSBmcm9tIGNhbWVsQ2FzZSB0byBzbmFrZV9jYXNlXHJcbiAgICAgIGlmIChjb25maWcuZGF0YSAmJiB0eXBlb2YgY29uZmlnLmRhdGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIG5lc3RlZCBKU09OIG9iamVjdHMgdGhhdCBtaWdodCBiZSBzdHJpbmdzXHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHsgLi4uY29uZmlnLmRhdGEgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBFbnN1cmUgdGhlc2UgZmllbGRzIGFyZSBwcm9wZXJseSBzZXJpYWxpemVkIGZvciB0aGUgQVBJXHJcbiAgICAgICAgWydtZWRpY2FsSGlzdG9yeScsICdwaHlzaWNhbEdlbmVyYWxzJywgJ21lbnN0cnVhbEhpc3RvcnknLCAnZm9vZEFuZEhhYml0J10uZm9yRWFjaChmaWVsZCA9PiB7XHJcbiAgICAgICAgICBpZiAocHJvY2Vzc2VkRGF0YVtmaWVsZF0gJiYgdHlwZW9mIHByb2Nlc3NlZERhdGFbZmllbGRdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHByb2Nlc3NlZERhdGFbZmllbGRdID0gSlNPTi5wYXJzZShwcm9jZXNzZWREYXRhW2ZpZWxkXSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgYSB2YWxpZCBKU09OIG9iamVjdCwgdGhpcyB3aWxsIGZhaWwsIHdoaWNoIGlzIGZpbmVcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmllbGQgJHtmaWVsZH0gaXMgYWxyZWFkeSBwYXJzZWQgb3Igbm90IHZhbGlkIEpTT05gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbmZpZy5kYXRhID0gY2FtZWxUb1NuYWtlQ2FzZShwcm9jZXNzZWREYXRhKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVHJhbnNmb3JtIFVSTCBwYXJhbWV0ZXJzIGZyb20gY2FtZWxDYXNlIHRvIHNuYWtlX2Nhc2VcclxuICAgICAgaWYgKGNvbmZpZy5wYXJhbXMgJiYgdHlwZW9mIGNvbmZpZy5wYXJhbXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY29uZmlnLnBhcmFtcyA9IGNhbWVsVG9TbmFrZUNhc2UoY29uZmlnLnBhcmFtcyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiByZXF1ZXN0IGludGVyY2VwdG9yOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGNvbmZpZzsgLy8gUmV0dXJuIHRoZSBvcmlnaW5hbCBjb25maWcgaWYgdHJhbnNmb3JtYXRpb24gZmFpbHNcclxuICAgIH1cclxuICB9LFxyXG4gIChlcnJvcikgPT4ge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICB9XHJcbik7XHJcblxyXG4vLyBFbmhhbmNlZCByZXNwb25zZSBpbnRlcmNlcHRvclxyXG5hcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcclxuICAocmVzcG9uc2UpID0+IHtcclxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhIGZyb20gc25ha2VfY2FzZSB0byBjYW1lbENhc2VcclxuICAgIGlmIChyZXNwb25zZS5kYXRhKSB7XHJcbiAgICAgIHJlc3BvbnNlLmRhdGEgPSBzbmFrZVRvQ2FtZWxDYXNlKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gIH0sXHJcbiAgYXN5bmMgKGVycm9yKSA9PiB7XHJcbiAgICBjb25zdCBjb25maWcgPSBlcnJvci5jb25maWc7XHJcbiAgICBcclxuICAgIC8vIFRyYW5zZm9ybSBlcnJvciByZXNwb25zZSBkYXRhIGZyb20gc25ha2VfY2FzZSB0byBjYW1lbENhc2VcclxuICAgIGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5kYXRhKSB7XHJcbiAgICAgIGVycm9yLnJlc3BvbnNlLmRhdGEgPSBzbmFrZVRvQ2FtZWxDYXNlKGVycm9yLnJlc3BvbnNlLmRhdGEpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZXRyeSBsb2dpYyBmb3IgbmV0d29yayBlcnJvcnMgYW5kIDV4eCBlcnJvcnNcclxuICAgIGlmIChjb25maWcgJiYgY29uZmlnLnJldHJ5ICYmIChcclxuICAgICAgIWVycm9yLnJlc3BvbnNlIHx8IFxyXG4gICAgICAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzID49IDUwMCAmJiBlcnJvci5yZXNwb25zZS5zdGF0dXMgPCA2MDApXHJcbiAgICApKSB7XHJcbiAgICAgIGNvbmZpZy5yZXRyeS0tO1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgY29uZmlnLnJldHJ5RGVsYXkpKTtcclxuICAgICAgcmV0dXJuIGFwaShjb25maWcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgQVBJIGVycm9yc1xyXG4gICAgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xyXG4gIH1cclxuKTtcclxuXHJcbi8vIEVuaGFuY2VkIFBhdGllbnRzIEFQSSB3aXRoIHZhbGlkYXRpb24gYW5kIGVycm9yIGhhbmRsaW5nXHJcbmV4cG9ydCBjb25zdCBwYXRpZW50c0FQSSA9IHtcclxuICBnZXRBbGxQYXRpZW50czogYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9wYXRpZW50cycsIHsgcGFyYW1zIH0pO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwYXRpZW50czonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldFBhdGllbnQ6IGFzeW5jIChpZCkgPT4ge1xyXG4gICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKCdQYXRpZW50IElEIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgL3BhdGllbnRzLyR7aWR9YCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGZldGNoIHBhdGllbnQgJHtpZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBjcmVhdGVQYXRpZW50OiBhc3luYyAoZGF0YSkgPT4ge1xyXG4gICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkIHBhdGllbnQgZGF0YSBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMgYmVmb3JlIHNlbmRpbmcgdG8gQVBJXHJcbiAgICBpZiAoIWRhdGEubmFtZSkgdGhyb3cgbmV3IEVycm9yKCdQYXRpZW50IG5hbWUgaXMgcmVxdWlyZWQnKTtcclxuICAgIGlmICghZGF0YS5hZGRyZXNzKSB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3MgaXMgcmVxdWlyZWQnKTtcclxuICAgIGlmICghZGF0YS5hZ2UpIHRocm93IG5ldyBFcnJvcignQWdlIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBpZiAoIWRhdGEuc2V4KSB0aHJvdyBuZXcgRXJyb3IoJ1NleCBpcyByZXF1aXJlZCcpO1xyXG4gICAgaWYgKCFkYXRhLm1vYmlsZU51bWJlcikgdGhyb3cgbmV3IEVycm9yKCdNb2JpbGUgbnVtYmVyIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBpZiAoIWRhdGEuY2hpZWZDb21wbGFpbnRzKSB0aHJvdyBuZXcgRXJyb3IoJ0NoaWVmIGNvbXBsYWludHMgYXJlIHJlcXVpcmVkJyk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEVuc3VyZSBKU09OIGZpZWxkcyBhcmUgcHJvcGVybHkgc3RydWN0dXJlZCB0byBhdm9pZCBpc3N1ZXNcclxuICAgICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHtcclxuICAgICAgICAuLi5kYXRhLFxyXG4gICAgICAgIG1lZGljYWxIaXN0b3J5OiBkYXRhLm1lZGljYWxIaXN0b3J5IHx8IHtcclxuICAgICAgICAgIHBhc3RIaXN0b3J5OiB7fSxcclxuICAgICAgICAgIGZhbWlseUhpc3Rvcnk6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwaHlzaWNhbEdlbmVyYWxzOiBkYXRhLnBoeXNpY2FsR2VuZXJhbHMgfHwge30sXHJcbiAgICAgICAgZm9vZEFuZEhhYml0OiBkYXRhLmZvb2RBbmRIYWJpdCB8fCB7fSxcclxuICAgICAgICAvLyBPbmx5IGluY2x1ZGUgbWVuc3RydWFsSGlzdG9yeSBmb3IgZmVtYWxlIHBhdGllbnRzXHJcbiAgICAgICAgbWVuc3RydWFsSGlzdG9yeTogZGF0YS5zZXggPT09ICdGZW1hbGUnID8gKGRhdGEubWVuc3RydWFsSGlzdG9yeSB8fCB7fSkgOiBudWxsXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvcGF0aWVudHMnLCBzYW5pdGl6ZWREYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHBhdGllbnQ6JywgZXJyb3IpO1xyXG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gY3JlYXRlIHBhdGllbnQnO1xyXG4gICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlscyB8fCAnJztcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgRXJyb3IgRGV0YWlsczonLCB7XHJcbiAgICAgICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZT8uc3RhdHVzLFxyXG4gICAgICAgIGRhdGE6IGVycm9yLnJlc3BvbnNlPy5kYXRhLFxyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcclxuICAgICAgICBkZXRhaWxzOiBlcnJvckRldGFpbHNcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfSR7ZXJyb3JEZXRhaWxzID8gJzogJyArIGVycm9yRGV0YWlscyA6ICcnfWApO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZVBhdGllbnQ6IGFzeW5jIChpZCwgZGF0YSkgPT4ge1xyXG4gICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKCdQYXRpZW50IElEIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWQgcGF0aWVudCBkYXRhIGlzIHJlcXVpcmVkJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL3BhdGllbnRzLyR7aWR9YCwgZGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBwYXRpZW50ICR7aWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVsZXRlUGF0aWVudDogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoJ1BhdGllbnQgSUQgaXMgcmVxdWlyZWQnKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZGVsZXRlKGAvcGF0aWVudHMvJHtpZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIHBhdGllbnQgJHtpZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG59O1xyXG5cclxuLy8gRW5oYW5jZWQgSW52ZXN0aWdhdGlvbnMgQVBJXHJcbmV4cG9ydCBjb25zdCBpbnZlc3RpZ2F0aW9uc0FQSSA9IHtcclxuICBnZXRBbGxJbnZlc3RpZ2F0aW9uczogYXN5bmMgKHBhdGllbnRJZCA9IG51bGwpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHBhdGllbnRJZCA/IHsgcGF0aWVudElkIH0gOiB7fTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvaW52ZXN0aWdhdGlvbnMnLCB7IHBhcmFtcyB9KTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggaW52ZXN0aWdhdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRJbnZlc3RpZ2F0aW9uOiBhc3luYyAoaWQpID0+IHtcclxuICAgIGlmICghaWQpIHRocm93IG5ldyBFcnJvcignSW52ZXN0aWdhdGlvbiBJRCBpcyByZXF1aXJlZCcpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9pbnZlc3RpZ2F0aW9ucy8ke2lkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCBpbnZlc3RpZ2F0aW9uICR7aWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlSW52ZXN0aWdhdGlvbjogYXN5bmMgKGRhdGEpID0+IHtcclxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWxpZCBpbnZlc3RpZ2F0aW9uIGRhdGEgaXMgcmVxdWlyZWQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2ludmVzdGlnYXRpb25zJywgZGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBpbnZlc3RpZ2F0aW9uOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlSW52ZXN0aWdhdGlvbjogYXN5bmMgKGlkLCBkYXRhKSA9PiB7XHJcbiAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmVzdGlnYXRpb24gSUQgaXMgcmVxdWlyZWQnKTtcclxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWxpZCBpbnZlc3RpZ2F0aW9uIGRhdGEgaXMgcmVxdWlyZWQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvaW52ZXN0aWdhdGlvbnMvJHtpZH1gLCBkYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIGludmVzdGlnYXRpb24gJHtpZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBkZWxldGVJbnZlc3RpZ2F0aW9uOiBhc3luYyAoaWQpID0+IHtcclxuICAgIGlmICghaWQpIHRocm93IG5ldyBFcnJvcignSW52ZXN0aWdhdGlvbiBJRCBpcyByZXF1aXJlZCcpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5kZWxldGUoYC9pbnZlc3RpZ2F0aW9ucy8ke2lkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBkZWxldGUgaW52ZXN0aWdhdGlvbiAke2lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG4vLyBFbmhhbmNlZCBBdXRoL1VzZXJzIEFQSVxyXG5leHBvcnQgY29uc3QgYXV0aEFQSSA9IHtcclxuICBnZXRDdXJyZW50VXNlcjogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvdXNlcnMvbWUnKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggY3VycmVudCB1c2VyOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0VXNlcnM6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3VzZXJzJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIHVzZXJzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBUaGVzZSBhcmUgaGFuZGxlZCBieSBOZXh0QXV0aCwgYnV0IGtlZXBpbmcgZm9yIGNvbXBhdGliaWxpdHlcclxuICBsb2dpbjogYXN5bmMgKGVtYWlsLCBwYXNzd29yZCkgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgTmV4dEF1dGggc2lnbkluIGluc3RlYWQgb2YgdGhpcyBtZXRob2QnKTtcclxuICB9LFxyXG4gIFxyXG4gIGxvZ291dDogYXN5bmMgKCkgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgTmV4dEF1dGggc2lnbk91dCBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kJyk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEVuaGFuY2VkIEhlYWx0aCBjaGVjayBBUElcclxuZXhwb3J0IGNvbnN0IGhlYWx0aEFQSSA9IHtcclxuICBjaGVjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvaGVhbHRoJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignSGVhbHRoIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgY29tbW9uIG9wZXJhdGlvbnNcclxuZXhwb3J0IGNvbnN0IGFwaVV0aWxzID0ge1xyXG4gIC8vIENoZWNrIGlmIEFQSSBpcyBhdmFpbGFibGVcclxuICBpc0FwaUhlYWx0aHk6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGhlYWx0aEFQSS5jaGVjaygpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gVGVzdCBkYXRhYmFzZSBjb25uZWN0aW9uXHJcbiAgdGVzdENvbm5lY3Rpb246IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGF3YWl0IGhlYWx0aEFQSS5jaGVjaygpO1xyXG4gICAgICByZXR1cm4gaGVhbHRoLmRhdGFiYXNlID09PSAnY29ubmVjdGVkJztcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gR2V0IEFQSSBiYXNlIFVSTFxyXG4gIGdldEJhc2VVcmw6ICgpID0+IGAke0JBU0VfVVJMfS9hcGlgLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXBpO1xyXG4iXSwibmFtZXMiOlsiYXhpb3MiLCJzbmFrZVRvQ2FtZWxDYXNlIiwiY2FtZWxUb1NuYWtlQ2FzZSIsInRyYW5zZm9ybUlmTmVlZGVkIiwiQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsInJldHJ5IiwicmV0cnlEZWxheSIsImhhbmRsZUFwaUVycm9yIiwiZXJyb3IiLCJyZXNwb25zZSIsInN0YXR1cyIsImRhdGEiLCJFcnJvciIsIm1lc3NhZ2UiLCJyZXF1ZXN0IiwicmV0cnlSZXF1ZXN0IiwiY29uZmlnIiwiaSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImludGVyY2VwdG9ycyIsInVzZSIsInByb2Nlc3NlZERhdGEiLCJmb3JFYWNoIiwiZmllbGQiLCJKU09OIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImxvZyIsInBhcmFtcyIsInJlamVjdCIsInBhdGllbnRzQVBJIiwiZ2V0QWxsUGF0aWVudHMiLCJnZXQiLCJnZXRQYXRpZW50IiwiaWQiLCJjcmVhdGVQYXRpZW50IiwibmFtZSIsImFkZHJlc3MiLCJhZ2UiLCJzZXgiLCJtb2JpbGVOdW1iZXIiLCJjaGllZkNvbXBsYWludHMiLCJzYW5pdGl6ZWREYXRhIiwibWVkaWNhbEhpc3RvcnkiLCJwYXN0SGlzdG9yeSIsImZhbWlseUhpc3RvcnkiLCJwaHlzaWNhbEdlbmVyYWxzIiwiZm9vZEFuZEhhYml0IiwibWVuc3RydWFsSGlzdG9yeSIsInBvc3QiLCJlcnJvck1lc3NhZ2UiLCJlcnJvckRldGFpbHMiLCJkZXRhaWxzIiwidXBkYXRlUGF0aWVudCIsInB1dCIsImRlbGV0ZVBhdGllbnQiLCJkZWxldGUiLCJpbnZlc3RpZ2F0aW9uc0FQSSIsImdldEFsbEludmVzdGlnYXRpb25zIiwicGF0aWVudElkIiwiZ2V0SW52ZXN0aWdhdGlvbiIsImNyZWF0ZUludmVzdGlnYXRpb24iLCJ1cGRhdGVJbnZlc3RpZ2F0aW9uIiwiZGVsZXRlSW52ZXN0aWdhdGlvbiIsImF1dGhBUEkiLCJnZXRDdXJyZW50VXNlciIsImdldFVzZXJzIiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwibG9nb3V0IiwiaGVhbHRoQVBJIiwiY2hlY2siLCJhcGlVdGlscyIsImlzQXBpSGVhbHRoeSIsInRlc3RDb25uZWN0aW9uIiwiaGVhbHRoIiwiZGF0YWJhc2UiLCJnZXRCYXNlVXJsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/services/api-nextjs.js\n"));

/***/ })

});