"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/utils/dataTransform.js":
/*!************************************!*\
  !*** ./src/utils/dataTransform.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camelToSnakeCase: function() { return /* binding */ camelToSnakeCase; },\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   needsTransformation: function() { return /* binding */ needsTransformation; },\n/* harmony export */   snakeToCamelCase: function() { return /* binding */ snakeToCamelCase; },\n/* harmony export */   transformIfNeeded: function() { return /* binding */ transformIfNeeded; }\n/* harmony export */ });\n/**\r\n * Utility functions to transform data between camelCase (frontend) and snake_case (backend)\r\n * This utility ensures consistent data format between the React frontend and FastAPI backend\r\n */ /**\r\n * Checks if a value should be processed for key transformation\r\n * @param {*} value - The value to check\r\n * @returns {boolean} Whether the value should be processed\r\n */ const shouldProcessValue = (value)=>{\n    return value !== null && value !== undefined && typeof value === \"object\" && !(value instanceof File) && !(value instanceof Blob) && !(value instanceof Date) && !(value instanceof FormData);\n};\n/**\r\n * Converts snake_case string to camelCase\r\n * @param {string} str - Snake case string\r\n * @returns {string} Camel case string\r\n */ const snakeToCamel = (str)=>{\n    return str.replace(/_([a-z])/g, (match, group)=>group.toUpperCase());\n};\n/**\r\n * Converts camelCase string to snake_case\r\n * @param {string} str - Camel case string\r\n * @returns {string} Snake case string\r\n */ const camelToSnake = (str)=>{\n    return str.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n};\n/**\r\n * Converts snake_case keys to camelCase throughout an object or array\r\n * @param {Object|Array} data - Data with snake_case keys\r\n * @returns {Object|Array} Data with camelCase keys\r\n */ function snakeToCamelCase(data) {\n    if (!shouldProcessValue(data)) {\n        return data;\n    }\n    if (Array.isArray(data)) {\n        return data.map(snakeToCamelCase);\n    }\n    return Object.entries(data).reduce((result, param)=>{\n        let [key, value] = param;\n        // Convert key from snake_case to camelCase\n        const camelKey = snakeToCamel(key);\n        // Recursively transform nested objects and arrays\n        result[camelKey] = shouldProcessValue(value) ? snakeToCamelCase(value) : value;\n        return result;\n    }, {});\n}\n/**\r\n * Converts camelCase keys to snake_case throughout an object or array\r\n * @param {Object|Array} data - Data with camelCase keys\r\n * @returns {Object|Array} Data with snake_case keys\r\n */ function camelToSnakeCase(data) {\n    if (!shouldProcessValue(data)) {\n        return data;\n    }\n    if (Array.isArray(data)) {\n        return data.map(camelToSnakeCase);\n    }\n    return Object.entries(data).reduce((result, param)=>{\n        let [key, value] = param;\n        // Convert key from camelCase to snake_case\n        const snakeKey = camelToSnake(key);\n        // Recursively transform nested objects and arrays\n        result[snakeKey] = shouldProcessValue(value) ? camelToSnakeCase(value) : value;\n        return result;\n    }, {});\n}\n/**\r\n * Determines if an object needs transformation (has keys in the wrong format)\r\n * @param {Object} obj - The object to check\r\n * @param {boolean} lookForSnakeCase - Whether to look for snake_case (true) or camelCase (false) \r\n * @returns {boolean} Whether the object contains keys in the format we're checking for\r\n */ function needsTransformation(obj) {\n    let lookForSnakeCase = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    if (!shouldProcessValue(obj)) {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        // Check the first element if it's an array\n        return obj.length > 0 ? needsTransformation(obj[0], lookForSnakeCase) : false;\n    }\n    // Check if any key matches the pattern we're looking for\n    return Object.keys(obj).some((key)=>{\n        if (lookForSnakeCase) {\n            // Looking for snake_case keys (contains underscores)\n            return key.includes(\"_\");\n        } else {\n            // Looking for camelCase keys (contains uppercase letter not at the start)\n            return /[A-Z]/.test(key) && key[0] !== key[0].toUpperCase();\n        }\n    });\n}\n/**\r\n * Transforms data if needed based on the target format\r\n * @param {Object|Array} data - The data to potentially transform\r\n * @param {boolean} toSnakeCase - Direction of the transformation (true for camelCase â†’ snake_case)\r\n * @returns {Object|Array} Transformed data or original if no transformation needed\r\n */ function transformIfNeeded(data) {\n    let toSnakeCase = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    if (!shouldProcessValue(data)) {\n        return data;\n    }\n    // Check if transformation is needed\n    const needsConversion = needsTransformation(data, !toSnakeCase);\n    // If transformation is needed, apply the appropriate conversion function\n    if (needsConversion) {\n        return toSnakeCase ? camelToSnakeCase(data) : snakeToCamelCase(data);\n    }\n    return data;\n}\n/**\r\n * Format a date string or Date object to a readable format\r\n * @param {string|Date} dateString - The date to format\r\n * @param {boolean} includeTime - Whether to include the time in the output\r\n * @returns {string} Formatted date string\r\n */ function formatDate(dateString) {\n    let includeTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    if (!dateString) return \"\";\n    try {\n        const date = new Date(dateString);\n        // Check if date is valid\n        if (isNaN(date.getTime())) {\n            return dateString;\n        }\n        const options = {\n            year: \"numeric\",\n            month: \"short\",\n            day: \"numeric\"\n        };\n        if (includeTime) {\n            options.hour = \"2-digit\";\n            options.minute = \"2-digit\";\n        }\n        return date.toLocaleDateString(\"en-US\", options);\n    } catch (error) {\n        console.error(\"Error formatting date:\", error);\n        return dateString;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDVDtJQUVBLG9DQUFvQztJQUNwQyxNQUFNc0Isa0JBQWtCVixvQkFBb0JaLE1BQU0sQ0FBQ3FCO0lBRW5ELHlFQUF5RTtJQUN6RSxJQUFJQyxpQkFBaUI7UUFDbkIsT0FBT0QsY0FBY1gsaUJBQWlCVixRQUFRRCxpQkFBaUJDO0lBQ2pFO0lBRUEsT0FBT0E7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU3VCLFdBQVdDLFVBQVU7UUFBRUMsY0FBQUEsaUVBQWM7SUFDbkQsSUFBSSxDQUFDRCxZQUFZLE9BQU87SUFFeEIsSUFBSTtRQUNGLE1BQU1FLE9BQU8sSUFBSXJDLEtBQUttQztRQUV0Qix5QkFBeUI7UUFDekIsSUFBSUcsTUFBTUQsS0FBS0UsT0FBTyxLQUFLO1lBQ3pCLE9BQU9KO1FBQ1Q7UUFFQSxNQUFNSyxVQUFVO1lBQ2RDLE1BQU07WUFDTkMsT0FBTztZQUNQQyxLQUFLO1FBQ1A7UUFFQSxJQUFJUCxhQUFhO1lBQ2ZJLFFBQVFJLElBQUksR0FBRztZQUNmSixRQUFRSyxNQUFNLEdBQUc7UUFDbkI7UUFFQSxPQUFPUixLQUFLUyxrQkFBa0IsQ0FBQyxTQUFTTjtJQUMxQyxFQUFFLE9BQU9PLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsT0FBT1o7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9kYXRhVHJhbnNmb3JtLmpzPzJkODUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHRyYW5zZm9ybSBkYXRhIGJldHdlZW4gY2FtZWxDYXNlIChmcm9udGVuZCkgYW5kIHNuYWtlX2Nhc2UgKGJhY2tlbmQpXHJcbiAqIFRoaXMgdXRpbGl0eSBlbnN1cmVzIGNvbnNpc3RlbnQgZGF0YSBmb3JtYXQgYmV0d2VlbiB0aGUgUmVhY3QgZnJvbnRlbmQgYW5kIEZhc3RBUEkgYmFja2VuZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBzaG91bGQgYmUgcHJvY2Vzc2VkIGZvciBrZXkgdHJhbnNmb3JtYXRpb25cclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdmFsdWUgc2hvdWxkIGJlIHByb2Nlc3NlZFxyXG4gKi9cclxuY29uc3Qgc2hvdWxkUHJvY2Vzc1ZhbHVlID0gKHZhbHVlKSA9PiB7XHJcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIFxyXG4gICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIFxyXG4gICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBGaWxlKSAmJlxyXG4gICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgQmxvYikgJiZcclxuICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmXHJcbiAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgc25ha2VfY2FzZSBzdHJpbmcgdG8gY2FtZWxDYXNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTbmFrZSBjYXNlIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDYW1lbCBjYXNlIHN0cmluZ1xyXG4gKi9cclxuY29uc3Qgc25ha2VUb0NhbWVsID0gKHN0cikgPT4ge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXyhbYS16XSkvZywgKG1hdGNoLCBncm91cCkgPT4gZ3JvdXAudG9VcHBlckNhc2UoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgY2FtZWxDYXNlIHN0cmluZyB0byBzbmFrZV9jYXNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBDYW1lbCBjYXNlIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTbmFrZSBjYXNlIHN0cmluZ1xyXG4gKi9cclxuY29uc3QgY2FtZWxUb1NuYWtlID0gKHN0cikgPT4ge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCAnXyQxJykudG9Mb3dlckNhc2UoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIGtleXMgdG8gY2FtZWxDYXNlIHRocm91Z2hvdXQgYW4gb2JqZWN0IG9yIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhIC0gRGF0YSB3aXRoIHNuYWtlX2Nhc2Uga2V5c1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fEFycmF5fSBEYXRhIHdpdGggY2FtZWxDYXNlIGtleXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzbmFrZVRvQ2FtZWxDYXNlKGRhdGEpIHtcclxuICBpZiAoIXNob3VsZFByb2Nlc3NWYWx1ZShkYXRhKSkge1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgcmV0dXJuIGRhdGEubWFwKHNuYWtlVG9DYW1lbENhc2UpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgocmVzdWx0LCBba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgIC8vIENvbnZlcnQga2V5IGZyb20gc25ha2VfY2FzZSB0byBjYW1lbENhc2VcclxuICAgIGNvbnN0IGNhbWVsS2V5ID0gc25ha2VUb0NhbWVsKGtleSk7XHJcbiAgICBcclxuICAgIC8vIFJlY3Vyc2l2ZWx5IHRyYW5zZm9ybSBuZXN0ZWQgb2JqZWN0cyBhbmQgYXJyYXlzXHJcbiAgICByZXN1bHRbY2FtZWxLZXldID0gc2hvdWxkUHJvY2Vzc1ZhbHVlKHZhbHVlKSA/IHNuYWtlVG9DYW1lbENhc2UodmFsdWUpIDogdmFsdWU7XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSwge30pO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgY2FtZWxDYXNlIGtleXMgdG8gc25ha2VfY2FzZSB0aHJvdWdob3V0IGFuIG9iamVjdCBvciBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0YSAtIERhdGEgd2l0aCBjYW1lbENhc2Uga2V5c1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fEFycmF5fSBEYXRhIHdpdGggc25ha2VfY2FzZSBrZXlzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxUb1NuYWtlQ2FzZShkYXRhKSB7XHJcbiAgaWYgKCFzaG91bGRQcm9jZXNzVmFsdWUoZGF0YSkpIHtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuICBcclxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgcmV0dXJuIGRhdGEubWFwKGNhbWVsVG9TbmFrZUNhc2UpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChyZXN1bHQsIFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgLy8gQ29udmVydCBrZXkgZnJvbSBjYW1lbENhc2UgdG8gc25ha2VfY2FzZVxyXG4gICAgY29uc3Qgc25ha2VLZXkgPSBjYW1lbFRvU25ha2Uoa2V5KTtcclxuICAgIFxyXG4gICAgLy8gUmVjdXJzaXZlbHkgdHJhbnNmb3JtIG5lc3RlZCBvYmplY3RzIGFuZCBhcnJheXNcclxuICAgIHJlc3VsdFtzbmFrZUtleV0gPSBzaG91bGRQcm9jZXNzVmFsdWUodmFsdWUpID8gY2FtZWxUb1NuYWtlQ2FzZSh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9LCB7fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBuZWVkcyB0cmFuc2Zvcm1hdGlvbiAoaGFzIGtleXMgaW4gdGhlIHdyb25nIGZvcm1hdClcclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gY2hlY2tcclxuICogQHBhcmFtIHtib29sZWFufSBsb29rRm9yU25ha2VDYXNlIC0gV2hldGhlciB0byBsb29rIGZvciBzbmFrZV9jYXNlICh0cnVlKSBvciBjYW1lbENhc2UgKGZhbHNlKSBcclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG9iamVjdCBjb250YWlucyBrZXlzIGluIHRoZSBmb3JtYXQgd2UncmUgY2hlY2tpbmcgZm9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbmVlZHNUcmFuc2Zvcm1hdGlvbihvYmosIGxvb2tGb3JTbmFrZUNhc2UgPSB0cnVlKSB7XHJcbiAgaWYgKCFzaG91bGRQcm9jZXNzVmFsdWUob2JqKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBcclxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAvLyBDaGVjayB0aGUgZmlyc3QgZWxlbWVudCBpZiBpdCdzIGFuIGFycmF5XHJcbiAgICByZXR1cm4gb2JqLmxlbmd0aCA+IDAgPyBuZWVkc1RyYW5zZm9ybWF0aW9uKG9ialswXSwgbG9va0ZvclNuYWtlQ2FzZSkgOiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgLy8gQ2hlY2sgaWYgYW55IGtleSBtYXRjaGVzIHRoZSBwYXR0ZXJuIHdlJ3JlIGxvb2tpbmcgZm9yXHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29tZShrZXkgPT4ge1xyXG4gICAgaWYgKGxvb2tGb3JTbmFrZUNhc2UpIHtcclxuICAgICAgLy8gTG9va2luZyBmb3Igc25ha2VfY2FzZSBrZXlzIChjb250YWlucyB1bmRlcnNjb3JlcylcclxuICAgICAgcmV0dXJuIGtleS5pbmNsdWRlcygnXycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gTG9va2luZyBmb3IgY2FtZWxDYXNlIGtleXMgKGNvbnRhaW5zIHVwcGVyY2FzZSBsZXR0ZXIgbm90IGF0IHRoZSBzdGFydClcclxuICAgICAgcmV0dXJuIC9bQS1aXS8udGVzdChrZXkpICYmIGtleVswXSAhPT0ga2V5WzBdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIGRhdGEgaWYgbmVlZGVkIGJhc2VkIG9uIHRoZSB0YXJnZXQgZm9ybWF0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gcG90ZW50aWFsbHkgdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9TbmFrZUNhc2UgLSBEaXJlY3Rpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uICh0cnVlIGZvciBjYW1lbENhc2Ug4oaSIHNuYWtlX2Nhc2UpXHJcbiAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl9IFRyYW5zZm9ybWVkIGRhdGEgb3Igb3JpZ2luYWwgaWYgbm8gdHJhbnNmb3JtYXRpb24gbmVlZGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtSWZOZWVkZWQoZGF0YSwgdG9TbmFrZUNhc2UgPSB0cnVlKSB7XHJcbiAgaWYgKCFzaG91bGRQcm9jZXNzVmFsdWUoZGF0YSkpIHtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuICBcclxuICAvLyBDaGVjayBpZiB0cmFuc2Zvcm1hdGlvbiBpcyBuZWVkZWRcclxuICBjb25zdCBuZWVkc0NvbnZlcnNpb24gPSBuZWVkc1RyYW5zZm9ybWF0aW9uKGRhdGEsICF0b1NuYWtlQ2FzZSk7XHJcbiAgXHJcbiAgLy8gSWYgdHJhbnNmb3JtYXRpb24gaXMgbmVlZGVkLCBhcHBseSB0aGUgYXBwcm9wcmlhdGUgY29udmVyc2lvbiBmdW5jdGlvblxyXG4gIGlmIChuZWVkc0NvbnZlcnNpb24pIHtcclxuICAgIHJldHVybiB0b1NuYWtlQ2FzZSA/IGNhbWVsVG9TbmFrZUNhc2UoZGF0YSkgOiBzbmFrZVRvQ2FtZWxDYXNlKGRhdGEpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBhIGRhdGUgc3RyaW5nIG9yIERhdGUgb2JqZWN0IHRvIGEgcmVhZGFibGUgZm9ybWF0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfERhdGV9IGRhdGVTdHJpbmcgLSBUaGUgZGF0ZSB0byBmb3JtYXRcclxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlVGltZSAtIFdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgdGltZSBpbiB0aGUgb3V0cHV0XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBkYXRlIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZVN0cmluZywgaW5jbHVkZVRpbWUgPSBmYWxzZSkge1xyXG4gIGlmICghZGF0ZVN0cmluZykgcmV0dXJuICcnO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIGRhdGUgaXMgdmFsaWRcclxuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcclxuICAgICAgcmV0dXJuIGRhdGVTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgIHllYXI6ICdudW1lcmljJyxcclxuICAgICAgbW9udGg6ICdzaG9ydCcsXHJcbiAgICAgIGRheTogJ251bWVyaWMnLFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgaWYgKGluY2x1ZGVUaW1lKSB7XHJcbiAgICAgIG9wdGlvbnMuaG91ciA9ICcyLWRpZ2l0JztcclxuICAgICAgb3B0aW9ucy5taW51dGUgPSAnMi1kaWdpdCc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCBvcHRpb25zKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZm9ybWF0dGluZyBkYXRlOicsIGVycm9yKTtcclxuICAgIHJldHVybiBkYXRlU3RyaW5nO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsic2hvdWxkUHJvY2Vzc1ZhbHVlIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJGaWxlIiwiQmxvYiIsIkRhdGUiLCJGb3JtRGF0YSIsInNuYWtlVG9DYW1lbCIsInN0ciIsInJlcGxhY2UiLCJtYXRjaCIsImdyb3VwIiwidG9VcHBlckNhc2UiLCJjYW1lbFRvU25ha2UiLCJ0b0xvd2VyQ2FzZSIsInNuYWtlVG9DYW1lbENhc2UiLCJkYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiT2JqZWN0IiwiZW50cmllcyIsInJlZHVjZSIsInJlc3VsdCIsImtleSIsImNhbWVsS2V5IiwiY2FtZWxUb1NuYWtlQ2FzZSIsInNuYWtlS2V5IiwibmVlZHNUcmFuc2Zvcm1hdGlvbiIsIm9iaiIsImxvb2tGb3JTbmFrZUNhc2UiLCJsZW5ndGgiLCJrZXlzIiwic29tZSIsImluY2x1ZGVzIiwidGVzdCIsInRyYW5zZm9ybUlmTmVlZGVkIiwidG9TbmFrZUNhc2UiLCJuZWVkc0NvbnZlcnNpb24iLCJmb3JtYXREYXRlIiwiZGF0ZVN0cmluZyIsImluY2x1ZGVUaW1lIiwiZGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsIm9wdGlvbnMiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiZXJyb3IiLCJjb25zb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/dataTransform.js\n"));

/***/ })

});