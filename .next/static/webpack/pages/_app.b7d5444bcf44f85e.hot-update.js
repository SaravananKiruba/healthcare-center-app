"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/services/api-nextjs.js":
/*!************************************!*\
  !*** ./src/services/api-nextjs.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiUtils: function() { return /* binding */ apiUtils; },\n/* harmony export */   authAPI: function() { return /* binding */ authAPI; },\n/* harmony export */   healthAPI: function() { return /* binding */ healthAPI; },\n/* harmony export */   investigationsAPI: function() { return /* binding */ investigationsAPI; },\n/* harmony export */   patientsAPI: function() { return /* binding */ patientsAPI; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var _utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/dataTransform */ \"./src/utils/dataTransform.js\");\n/**\r\n * Next.js API Service Module\r\n * \r\n * Enhanced API service with robust error handling, retry logic, and proper data transformation\r\n */ \n\nconst BASE_URL =  false ? 0 : \"http://localhost:3000\";\n// Create axios instance with enhanced configuration\nconst api = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n    baseURL: \"\".concat(BASE_URL, \"/api\"),\n    timeout: 30000,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    // Retry configuration\n    retry: 3,\n    retryDelay: 1000\n});\n// Enhanced error handler\nconst handleApiError = (error)=>{\n    if (error.response) {\n        // Server responded with error status\n        const { status, data } = error.response;\n        switch(status){\n            case 400:\n                throw new Error(data.message || \"Invalid request data\");\n            case 401:\n                throw new Error(\"Authentication required. Please log in again.\");\n            case 403:\n                throw new Error(\"You do not have permission to perform this action\");\n            case 404:\n                throw new Error(\"The requested resource was not found\");\n            case 409:\n                throw new Error(data.message || \"Resource conflict\");\n            case 422:\n                throw new Error(data.message || \"Validation error\");\n            case 500:\n                throw new Error(\"Internal server error. Please try again later.\");\n            default:\n                throw new Error(data.message || \"Request failed with status \".concat(status));\n        }\n    } else if (error.request) {\n        // Network error\n        throw new Error(\"Network error. Please check your connection and try again.\");\n    } else {\n        // Request setup error\n        throw new Error(error.message || \"An unexpected error occurred\");\n    }\n};\n// Retry logic for failed requests\nconst retryRequest = async (config)=>{\n    const { retry, retryDelay } = config;\n    for(let i = 0; i < retry; i++){\n        try {\n            return await (0,axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n        } catch (error) {\n            if (i === retry - 1) throw error;\n            // Don't retry client errors (4xx)\n            if (error.response && error.response.status >= 400 && error.response.status < 500) {\n                throw error;\n            }\n            // Wait before retry\n            await new Promise((resolve)=>setTimeout(resolve, retryDelay * (i + 1)));\n        }\n    }\n};\n// Enhanced request interceptor\napi.interceptors.request.use((config)=>{\n    // Transform request data from camelCase to snake_case\n    if (config.data && typeof config.data === \"object\") {\n        config.data = (0,_utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__.camelToSnakeCase)(config.data);\n    }\n    // Transform URL parameters from camelCase to snake_case\n    if (config.params && typeof config.params === \"object\") {\n        config.params = (0,_utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__.camelToSnakeCase)(config.params);\n    }\n    return config;\n}, (error)=>{\n    return Promise.reject(error);\n});\n// Enhanced response interceptor\napi.interceptors.response.use((response)=>{\n    // Transform response data from snake_case to camelCase\n    if (response.data) {\n        response.data = (0,_utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__.snakeToCamelCase)(response.data);\n    }\n    return response;\n}, async (error)=>{\n    const config = error.config;\n    // Transform error response data from snake_case to camelCase\n    if (error.response && error.response.data) {\n        error.response.data = (0,_utils_dataTransform__WEBPACK_IMPORTED_MODULE_0__.snakeToCamelCase)(error.response.data);\n    }\n    // Retry logic for network errors and 5xx errors\n    if (config && config.retry && (!error.response || error.response.status >= 500 && error.response.status < 600)) {\n        config.retry--;\n        await new Promise((resolve)=>setTimeout(resolve, config.retryDelay));\n        return api(config);\n    }\n    // Handle API errors\n    handleApiError(error);\n});\n// Enhanced Patients API with validation and error handling\nconst patientsAPI = {\n    getAllPatients: async function() {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        try {\n            const response = await api.get(\"/patients\", {\n                params\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch patients:\", error);\n            throw error;\n        }\n    },\n    getPatient: async (id)=>{\n        if (!id) throw new Error(\"Patient ID is required\");\n        try {\n            const response = await api.get(\"/patients/\".concat(id));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch patient \".concat(id, \":\"), error);\n            throw error;\n        }\n    },\n    createPatient: async (data)=>{\n        if (!data || typeof data !== \"object\") {\n            throw new Error(\"Valid patient data is required\");\n        }\n        // Validate required fields before sending to API\n        if (!data.name) throw new Error(\"Patient name is required\");\n        if (!data.address) throw new Error(\"Address is required\");\n        if (!data.age) throw new Error(\"Age is required\");\n        if (!data.sex) throw new Error(\"Sex is required\");\n        if (!data.mobileNumber) throw new Error(\"Mobile number is required\");\n        if (!data.chiefComplaints) throw new Error(\"Chief complaints are required\");\n        try {\n            // Ensure JSON fields are properly structured to avoid issues\n            const sanitizedData = {\n                ...data,\n                medicalHistory: data.medicalHistory || {\n                    pastHistory: {},\n                    familyHistory: {}\n                },\n                physicalGenerals: data.physicalGenerals || {},\n                foodAndHabit: data.foodAndHabit || {},\n                // Only include menstrualHistory for female patients\n                menstrualHistory: data.sex === \"Female\" ? data.menstrualHistory || {} : null\n            };\n            const response = await api.post(\"/patients\", sanitizedData);\n            return response.data;\n        } catch (error) {\n            var _error_response_data, _error_response, _error_response_data1, _error_response1, _error_response2, _error_response3;\n            console.error(\"Failed to create patient:\", error);\n            const errorMessage = ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message || \"Failed to create patient\";\n            const errorDetails = ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data1 = _error_response1.data) === null || _error_response_data1 === void 0 ? void 0 : _error_response_data1.details) || \"\";\n            console.log(\"API Error Details:\", {\n                status: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.status,\n                data: (_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.data,\n                message: errorMessage,\n                details: errorDetails\n            });\n            throw new Error(\"\".concat(errorMessage).concat(errorDetails ? \": \" + errorDetails : \"\"));\n        }\n    },\n    updatePatient: async (id, data)=>{\n        if (!id) throw new Error(\"Patient ID is required\");\n        if (!data || typeof data !== \"object\") {\n            throw new Error(\"Valid patient data is required\");\n        }\n        try {\n            const response = await api.put(\"/patients/\".concat(id), data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to update patient \".concat(id, \":\"), error);\n            throw error;\n        }\n    },\n    deletePatient: async (id)=>{\n        if (!id) throw new Error(\"Patient ID is required\");\n        try {\n            const response = await api.delete(\"/patients/\".concat(id));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to delete patient \".concat(id, \":\"), error);\n            throw error;\n        }\n    }\n};\n// Enhanced Investigations API\nconst investigationsAPI = {\n    getAllInvestigations: async function() {\n        let patientId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        try {\n            const params = patientId ? {\n                patientId\n            } : {};\n            const response = await api.get(\"/investigations\", {\n                params\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch investigations:\", error);\n            throw error;\n        }\n    },\n    getInvestigation: async (id)=>{\n        if (!id) throw new Error(\"Investigation ID is required\");\n        try {\n            const response = await api.get(\"/investigations/\".concat(id));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch investigation \".concat(id, \":\"), error);\n            throw error;\n        }\n    },\n    createInvestigation: async (data)=>{\n        if (!data || typeof data !== \"object\") {\n            throw new Error(\"Valid investigation data is required\");\n        }\n        try {\n            const response = await api.post(\"/investigations\", data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to create investigation:\", error);\n            throw error;\n        }\n    },\n    updateInvestigation: async (id, data)=>{\n        if (!id) throw new Error(\"Investigation ID is required\");\n        if (!data || typeof data !== \"object\") {\n            throw new Error(\"Valid investigation data is required\");\n        }\n        try {\n            const response = await api.put(\"/investigations/\".concat(id), data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to update investigation \".concat(id, \":\"), error);\n            throw error;\n        }\n    },\n    deleteInvestigation: async (id)=>{\n        if (!id) throw new Error(\"Investigation ID is required\");\n        try {\n            const response = await api.delete(\"/investigations/\".concat(id));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to delete investigation \".concat(id, \":\"), error);\n            throw error;\n        }\n    }\n};\n// Enhanced Auth/Users API\nconst authAPI = {\n    getCurrentUser: async ()=>{\n        try {\n            const response = await api.get(\"/users/me\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch current user:\", error);\n            throw error;\n        }\n    },\n    getUsers: async ()=>{\n        try {\n            const response = await api.get(\"/users\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch users:\", error);\n            throw error;\n        }\n    },\n    // These are handled by NextAuth, but keeping for compatibility\n    login: async (email, password)=>{\n        throw new Error(\"Use NextAuth signIn instead of this method\");\n    },\n    logout: async ()=>{\n        throw new Error(\"Use NextAuth signOut instead of this method\");\n    }\n};\n// Enhanced Health check API\nconst healthAPI = {\n    check: async ()=>{\n        try {\n            const response = await api.get(\"/health\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Health check failed:\", error);\n            throw error;\n        }\n    }\n};\n// Utility functions for common operations\nconst apiUtils = {\n    // Check if API is available\n    isApiHealthy: async ()=>{\n        try {\n            await healthAPI.check();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    },\n    // Test database connection\n    testConnection: async ()=>{\n        try {\n            const health = await healthAPI.check();\n            return health.database === \"connected\";\n        } catch (e) {\n            return false;\n        }\n    },\n    // Get API base URL\n    getBaseUrl: ()=>\"\".concat(BASE_URL, \"/api\")\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q29udGVudCI6WyIvKipcclxuICogTmV4dC5qcyBBUEkgU2VydmljZSBNb2R1bGVcclxuICogXHJcbiAqIEVuaGFuY2VkIEFQSSBzZXJ2aWNlIHdpdGggcm9idXN0IGVycm9yIGhhbmRsaW5nLCByZXRyeSBsb2dpYywgYW5kIHByb3BlciBkYXRhIHRyYW5zZm9ybWF0aW9uXHJcbiAqL1xyXG5cclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuaW1wb3J0IHsgXHJcbiAgICBzbmFrZVRvQ2FtZWxDYXNlLCBcclxuICAgIGNhbWVsVG9TbmFrZUNhc2UsXHJcbiAgICB0cmFuc2Zvcm1JZk5lZWRlZCBcclxufSBmcm9tICcuLi91dGlscy9kYXRhVHJhbnNmb3JtJztcclxuXHJcbmNvbnN0IEJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyBcclxuICA/IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHBzOi8veW91ci1hcHAudmVyY2VsLmFwcCdcclxuICA6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnO1xyXG5cclxuLy8gQ3JlYXRlIGF4aW9zIGluc3RhbmNlIHdpdGggZW5oYW5jZWQgY29uZmlndXJhdGlvblxyXG5jb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xyXG4gIGJhc2VVUkw6IGAke0JBU0VfVVJMfS9hcGlgLFxyXG4gIHRpbWVvdXQ6IDMwMDAwLFxyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfSxcclxuICAvLyBSZXRyeSBjb25maWd1cmF0aW9uXHJcbiAgcmV0cnk6IDMsXHJcbiAgcmV0cnlEZWxheTogMTAwMCxcclxufSk7XHJcblxyXG4vLyBFbmhhbmNlZCBlcnJvciBoYW5kbGVyXHJcbmNvbnN0IGhhbmRsZUFwaUVycm9yID0gKGVycm9yKSA9PiB7XHJcbiAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XHJcbiAgICAvLyBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3Igc3RhdHVzXHJcbiAgICBjb25zdCB7IHN0YXR1cywgZGF0YSB9ID0gZXJyb3IucmVzcG9uc2U7XHJcbiAgICBcclxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XHJcbiAgICAgIGNhc2UgNDAwOlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ0ludmFsaWQgcmVxdWVzdCBkYXRhJyk7XHJcbiAgICAgIGNhc2UgNDAxOlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gcmVxdWlyZWQuIFBsZWFzZSBsb2cgaW4gYWdhaW4uJyk7XHJcbiAgICAgIGNhc2UgNDAzOlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gcGVyZm9ybSB0aGlzIGFjdGlvbicpO1xyXG4gICAgICBjYXNlIDQwNDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXF1ZXN0ZWQgcmVzb3VyY2Ugd2FzIG5vdCBmb3VuZCcpO1xyXG4gICAgICBjYXNlIDQwOTpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdSZXNvdXJjZSBjb25mbGljdCcpO1xyXG4gICAgICBjYXNlIDQyMjpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdWYWxpZGF0aW9uIGVycm9yJyk7XHJcbiAgICAgIGNhc2UgNTAwOlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgc2VydmVyIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7c3RhdHVzfWApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZXJyb3IucmVxdWVzdCkge1xyXG4gICAgLy8gTmV0d29yayBlcnJvclxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uIGFuZCB0cnkgYWdhaW4uJyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFJlcXVlc3Qgc2V0dXAgZXJyb3JcclxuICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gUmV0cnkgbG9naWMgZm9yIGZhaWxlZCByZXF1ZXN0c1xyXG5jb25zdCByZXRyeVJlcXVlc3QgPSBhc3luYyAoY29uZmlnKSA9PiB7XHJcbiAgY29uc3QgeyByZXRyeSwgcmV0cnlEZWxheSB9ID0gY29uZmlnO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0cnk7IGkrKykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zKGNvbmZpZyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoaSA9PT0gcmV0cnkgLSAxKSB0aHJvdyBlcnJvcjtcclxuICAgICAgXHJcbiAgICAgIC8vIERvbid0IHJldHJ5IGNsaWVudCBlcnJvcnMgKDR4eClcclxuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgZXJyb3IucmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5ICogKGkgKyAxKSkpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8vIEVuaGFuY2VkIHJlcXVlc3QgaW50ZXJjZXB0b3JcclxuYXBpLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcclxuICAoY29uZmlnKSA9PiB7XHJcbiAgICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhIGZyb20gY2FtZWxDYXNlIHRvIHNuYWtlX2Nhc2VcclxuICAgIGlmIChjb25maWcuZGF0YSAmJiB0eXBlb2YgY29uZmlnLmRhdGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGNvbmZpZy5kYXRhID0gY2FtZWxUb1NuYWtlQ2FzZShjb25maWcuZGF0YSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFRyYW5zZm9ybSBVUkwgcGFyYW1ldGVycyBmcm9tIGNhbWVsQ2FzZSB0byBzbmFrZV9jYXNlXHJcbiAgICBpZiAoY29uZmlnLnBhcmFtcyAmJiB0eXBlb2YgY29uZmlnLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgY29uZmlnLnBhcmFtcyA9IGNhbWVsVG9TbmFrZUNhc2UoY29uZmlnLnBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBjb25maWc7XHJcbiAgfSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgfVxyXG4pO1xyXG5cclxuLy8gRW5oYW5jZWQgcmVzcG9uc2UgaW50ZXJjZXB0b3JcclxuYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXHJcbiAgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YSBmcm9tIHNuYWtlX2Nhc2UgdG8gY2FtZWxDYXNlXHJcbiAgICBpZiAocmVzcG9uc2UuZGF0YSkge1xyXG4gICAgICByZXNwb25zZS5kYXRhID0gc25ha2VUb0NhbWVsQ2FzZShyZXNwb25zZS5kYXRhKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXNwb25zZTtcclxuICB9LFxyXG4gIGFzeW5jIChlcnJvcikgPT4ge1xyXG4gICAgY29uc3QgY29uZmlnID0gZXJyb3IuY29uZmlnO1xyXG4gICAgXHJcbiAgICAvLyBUcmFuc2Zvcm0gZXJyb3IgcmVzcG9uc2UgZGF0YSBmcm9tIHNuYWtlX2Nhc2UgdG8gY2FtZWxDYXNlXHJcbiAgICBpZiAoZXJyb3IucmVzcG9uc2UgJiYgZXJyb3IucmVzcG9uc2UuZGF0YSkge1xyXG4gICAgICBlcnJvci5yZXNwb25zZS5kYXRhID0gc25ha2VUb0NhbWVsQ2FzZShlcnJvci5yZXNwb25zZS5kYXRhKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUmV0cnkgbG9naWMgZm9yIG5ldHdvcmsgZXJyb3JzIGFuZCA1eHggZXJyb3JzXHJcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5yZXRyeSAmJiAoXHJcbiAgICAgICFlcnJvci5yZXNwb25zZSB8fCBcclxuICAgICAgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgJiYgZXJyb3IucmVzcG9uc2Uuc3RhdHVzIDwgNjAwKVxyXG4gICAgKSkge1xyXG4gICAgICBjb25maWcucmV0cnktLTtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGNvbmZpZy5yZXRyeURlbGF5KSk7XHJcbiAgICAgIHJldHVybiBhcGkoY29uZmlnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIEFQSSBlcnJvcnNcclxuICAgIGhhbmRsZUFwaUVycm9yKGVycm9yKTtcclxuICB9XHJcbik7XHJcblxyXG4vLyBFbmhhbmNlZCBQYXRpZW50cyBBUEkgd2l0aCB2YWxpZGF0aW9uIGFuZCBlcnJvciBoYW5kbGluZ1xyXG5leHBvcnQgY29uc3QgcGF0aWVudHNBUEkgPSB7XHJcbiAgZ2V0QWxsUGF0aWVudHM6IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvcGF0aWVudHMnLCB7IHBhcmFtcyB9KTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcGF0aWVudHM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRQYXRpZW50OiBhc3luYyAoaWQpID0+IHtcclxuICAgIGlmICghaWQpIHRocm93IG5ldyBFcnJvcignUGF0aWVudCBJRCBpcyByZXF1aXJlZCcpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9wYXRpZW50cy8ke2lkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCBwYXRpZW50ICR7aWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlUGF0aWVudDogYXN5bmMgKGRhdGEpID0+IHtcclxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWxpZCBwYXRpZW50IGRhdGEgaXMgcmVxdWlyZWQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIGJlZm9yZSBzZW5kaW5nIHRvIEFQSVxyXG4gICAgaWYgKCFkYXRhLm5hbWUpIHRocm93IG5ldyBFcnJvcignUGF0aWVudCBuYW1lIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBpZiAoIWRhdGEuYWRkcmVzcykgdGhyb3cgbmV3IEVycm9yKCdBZGRyZXNzIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBpZiAoIWRhdGEuYWdlKSB0aHJvdyBuZXcgRXJyb3IoJ0FnZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgaWYgKCFkYXRhLnNleCkgdGhyb3cgbmV3IEVycm9yKCdTZXggaXMgcmVxdWlyZWQnKTtcclxuICAgIGlmICghZGF0YS5tb2JpbGVOdW1iZXIpIHRocm93IG5ldyBFcnJvcignTW9iaWxlIG51bWJlciBpcyByZXF1aXJlZCcpO1xyXG4gICAgaWYgKCFkYXRhLmNoaWVmQ29tcGxhaW50cykgdGhyb3cgbmV3IEVycm9yKCdDaGllZiBjb21wbGFpbnRzIGFyZSByZXF1aXJlZCcpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBFbnN1cmUgSlNPTiBmaWVsZHMgYXJlIHByb3Blcmx5IHN0cnVjdHVyZWQgdG8gYXZvaWQgaXNzdWVzXHJcbiAgICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB7XHJcbiAgICAgICAgLi4uZGF0YSxcclxuICAgICAgICBtZWRpY2FsSGlzdG9yeTogZGF0YS5tZWRpY2FsSGlzdG9yeSB8fCB7XHJcbiAgICAgICAgICBwYXN0SGlzdG9yeToge30sXHJcbiAgICAgICAgICBmYW1pbHlIaXN0b3J5OiB7fVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGh5c2ljYWxHZW5lcmFsczogZGF0YS5waHlzaWNhbEdlbmVyYWxzIHx8IHt9LFxyXG4gICAgICAgIGZvb2RBbmRIYWJpdDogZGF0YS5mb29kQW5kSGFiaXQgfHwge30sXHJcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIG1lbnN0cnVhbEhpc3RvcnkgZm9yIGZlbWFsZSBwYXRpZW50c1xyXG4gICAgICAgIG1lbnN0cnVhbEhpc3Rvcnk6IGRhdGEuc2V4ID09PSAnRmVtYWxlJyA/IChkYXRhLm1lbnN0cnVhbEhpc3RvcnkgfHwge30pIDogbnVsbFxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL3BhdGllbnRzJywgc2FuaXRpemVkRGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBwYXRpZW50OicsIGVycm9yKTtcclxuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGNyZWF0ZSBwYXRpZW50JztcclxuICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gZXJyb3IucmVzcG9uc2U/LmRhdGE/LmRldGFpbHMgfHwgJyc7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnQVBJIEVycm9yIERldGFpbHM6Jywge1xyXG4gICAgICAgIHN0YXR1czogZXJyb3IucmVzcG9uc2U/LnN0YXR1cyxcclxuICAgICAgICBkYXRhOiBlcnJvci5yZXNwb25zZT8uZGF0YSxcclxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXHJcbiAgICAgICAgZGV0YWlsczogZXJyb3JEZXRhaWxzXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yTWVzc2FnZX0ke2Vycm9yRGV0YWlscyA/ICc6ICcgKyBlcnJvckRldGFpbHMgOiAnJ31gKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGVQYXRpZW50OiBhc3luYyAoaWQsIGRhdGEpID0+IHtcclxuICAgIGlmICghaWQpIHRocm93IG5ldyBFcnJvcignUGF0aWVudCBJRCBpcyByZXF1aXJlZCcpO1xyXG4gICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkIHBhdGllbnQgZGF0YSBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoYC9wYXRpZW50cy8ke2lkfWAsIGRhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgcGF0aWVudCAke2lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGRlbGV0ZVBhdGllbnQ6IGFzeW5jIChpZCkgPT4ge1xyXG4gICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKCdQYXRpZW50IElEIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmRlbGV0ZShgL3BhdGllbnRzLyR7aWR9YCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBwYXRpZW50ICR7aWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEVuaGFuY2VkIEludmVzdGlnYXRpb25zIEFQSVxyXG5leHBvcnQgY29uc3QgaW52ZXN0aWdhdGlvbnNBUEkgPSB7XHJcbiAgZ2V0QWxsSW52ZXN0aWdhdGlvbnM6IGFzeW5jIChwYXRpZW50SWQgPSBudWxsKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJhbXMgPSBwYXRpZW50SWQgPyB7IHBhdGllbnRJZCB9IDoge307XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2ludmVzdGlnYXRpb25zJywgeyBwYXJhbXMgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGludmVzdGlnYXRpb25zOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0SW52ZXN0aWdhdGlvbjogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmVzdGlnYXRpb24gSUQgaXMgcmVxdWlyZWQnKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvaW52ZXN0aWdhdGlvbnMvJHtpZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaW52ZXN0aWdhdGlvbiAke2lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZUludmVzdGlnYXRpb246IGFzeW5jIChkYXRhKSA9PiB7XHJcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWQgaW52ZXN0aWdhdGlvbiBkYXRhIGlzIHJlcXVpcmVkJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9pbnZlc3RpZ2F0aW9ucycsIGRhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgaW52ZXN0aWdhdGlvbjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZUludmVzdGlnYXRpb246IGFzeW5jIChpZCwgZGF0YSkgPT4ge1xyXG4gICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZlc3RpZ2F0aW9uIElEIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWQgaW52ZXN0aWdhdGlvbiBkYXRhIGlzIHJlcXVpcmVkJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL2ludmVzdGlnYXRpb25zLyR7aWR9YCwgZGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBpbnZlc3RpZ2F0aW9uICR7aWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVsZXRlSW52ZXN0aWdhdGlvbjogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmVzdGlnYXRpb24gSUQgaXMgcmVxdWlyZWQnKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZGVsZXRlKGAvaW52ZXN0aWdhdGlvbnMvJHtpZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIGludmVzdGlnYXRpb24gJHtpZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG59O1xyXG5cclxuLy8gRW5oYW5jZWQgQXV0aC9Vc2VycyBBUElcclxuZXhwb3J0IGNvbnN0IGF1dGhBUEkgPSB7XHJcbiAgZ2V0Q3VycmVudFVzZXI6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3VzZXJzL21lJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGN1cnJlbnQgdXNlcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldFVzZXJzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy91c2VycycpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB1c2VyczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVGhlc2UgYXJlIGhhbmRsZWQgYnkgTmV4dEF1dGgsIGJ1dCBrZWVwaW5nIGZvciBjb21wYXRpYmlsaXR5XHJcbiAgbG9naW46IGFzeW5jIChlbWFpbCwgcGFzc3dvcmQpID0+IHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVXNlIE5leHRBdXRoIHNpZ25JbiBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kJyk7XHJcbiAgfSxcclxuICBcclxuICBsb2dvdXQ6IGFzeW5jICgpID0+IHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVXNlIE5leHRBdXRoIHNpZ25PdXQgaW5zdGVhZCBvZiB0aGlzIG1ldGhvZCcpO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vLyBFbmhhbmNlZCBIZWFsdGggY2hlY2sgQVBJXHJcbmV4cG9ydCBjb25zdCBoZWFsdGhBUEkgPSB7XHJcbiAgY2hlY2s6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2hlYWx0aCcpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0hlYWx0aCBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG59O1xyXG5cclxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbW1vbiBvcGVyYXRpb25zXHJcbmV4cG9ydCBjb25zdCBhcGlVdGlscyA9IHtcclxuICAvLyBDaGVjayBpZiBBUEkgaXMgYXZhaWxhYmxlXHJcbiAgaXNBcGlIZWFsdGh5OiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBoZWFsdGhBUEkuY2hlY2soKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFRlc3QgZGF0YWJhc2UgY29ubmVjdGlvblxyXG4gIHRlc3RDb25uZWN0aW9uOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBoZWFsdGggPSBhd2FpdCBoZWFsdGhBUEkuY2hlY2soKTtcclxuICAgICAgcmV0dXJuIGhlYWx0aC5kYXRhYmFzZSA9PT0gJ2Nvbm5lY3RlZCc7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIEdldCBBUEkgYmFzZSBVUkxcclxuICBnZXRCYXNlVXJsOiAoKSA9PiBgJHtCQVNFX1VSTH0vYXBpYCxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFwaTtcclxuIl0sIm5hbWVzIjpbImF4aW9zIiwic25ha2VUb0NhbWVsQ2FzZSIsImNhbWVsVG9TbmFrZUNhc2UiLCJ0cmFuc2Zvcm1JZk5lZWRlZCIsIkJBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJhcGkiLCJjcmVhdGUiLCJiYXNlVVJMIiwidGltZW91dCIsImhlYWRlcnMiLCJyZXRyeSIsInJldHJ5RGVsYXkiLCJoYW5kbGVBcGlFcnJvciIsImVycm9yIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJkYXRhIiwiRXJyb3IiLCJtZXNzYWdlIiwicmVxdWVzdCIsInJldHJ5UmVxdWVzdCIsImNvbmZpZyIsImkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJpbnRlcmNlcHRvcnMiLCJ1c2UiLCJwYXJhbXMiLCJyZWplY3QiLCJwYXRpZW50c0FQSSIsImdldEFsbFBhdGllbnRzIiwiZ2V0IiwiY29uc29sZSIsImdldFBhdGllbnQiLCJpZCIsImNyZWF0ZVBhdGllbnQiLCJuYW1lIiwiYWRkcmVzcyIsImFnZSIsInNleCIsIm1vYmlsZU51bWJlciIsImNoaWVmQ29tcGxhaW50cyIsInNhbml0aXplZERhdGEiLCJtZWRpY2FsSGlzdG9yeSIsInBhc3RIaXN0b3J5IiwiZmFtaWx5SGlzdG9yeSIsInBoeXNpY2FsR2VuZXJhbHMiLCJmb29kQW5kSGFiaXQiLCJtZW5zdHJ1YWxIaXN0b3J5IiwicG9zdCIsImVycm9yTWVzc2FnZSIsImVycm9yRGV0YWlscyIsImRldGFpbHMiLCJsb2ciLCJ1cGRhdGVQYXRpZW50IiwicHV0IiwiZGVsZXRlUGF0aWVudCIsImRlbGV0ZSIsImludmVzdGlnYXRpb25zQVBJIiwiZ2V0QWxsSW52ZXN0aWdhdGlvbnMiLCJwYXRpZW50SWQiLCJnZXRJbnZlc3RpZ2F0aW9uIiwiY3JlYXRlSW52ZXN0aWdhdGlvbiIsInVwZGF0ZUludmVzdGlnYXRpb24iLCJkZWxldGVJbnZlc3RpZ2F0aW9uIiwiYXV0aEFQSSIsImdldEN1cnJlbnRVc2VyIiwiZ2V0VXNlcnMiLCJsb2dpbiIsImVtYWlsIiwicGFzc3dvcmQiLCJsb2dvdXQiLCJoZWFsdGhBUEkiLCJjaGVjayIsImFwaVV0aWxzIiwiaXNBcGlIZWFsdGh5IiwidGVzdENvbm5lY3Rpb24iLCJoZWFsdGgiLCJkYXRhYmFzZSIsImdldEJhc2VVcmwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/services/api-nextjs.js\n"));

/***/ })

});